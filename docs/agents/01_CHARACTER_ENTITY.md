# CharacterEntity — модель персонажа (контракт)

**Источник истины:** `types.ts` (`interface CharacterEntity`), `data/entities/character-*.ts`, `data/character-schema.ts`.

## 1) Роль CharacterEntity в пайплайне

Персонаж — это *профиль агента*, который модулирует вычисления в пайплайне (S0…S8):

- **субъективность**: `CharacterLens` превращает сырой контекст `ctx:*` в субъективный `ctx:final:*`;
- **Theory of Mind**: dyad-метрики «A о B» (`tom:dyad:*`) опираются на оси `vector_base` и конфиги восприятия;
- **Goal Lab**: цели/режимы/утилиты опираются на `ctx:final:*`, драйверы `drv:*` и личные приоритеты `ctx:prio:*`.

Ключевой принцип: `CharacterEntity` не хранит весь мир и не “делает выбор”. Выбор делает пайплайн, а персонаж задаёт параметры, которые влияют на все промежуточные сигналы.

## 2) Состав CharacterEntity (то, что реально используется)

Тип (`types.ts`):

- `entityId`, `type`, `title` — идентификация;
- `vector_base?: Record<string, number>` — **вектор осей** (обычно [0,1]);
- `body: BodyModel` — телесная модель (структура для сенсоров);
- опциональные блоки: `identity`, `social`, `relationships`, `tom`, `resources`, `authority`, `evidence`, `observation`, `compute`, `lifeGoals`.

Важно: часть этих полей в текущем проекте “физически” живёт не в объекте, а в **атомах** (`world:*`, `feat:char:*`, `ctx:*`). Поэтому следует разделять:

- **профиль** (сущность персонажа, сравнительно стабилен);
- **состояние эпизода** (атомы, быстро меняются и объяснимы через trace).

## 3) `vector_base`: пространство психологических осей

`vector_base` — отображение

\[
\mathrm{vector\_base}: \mathcal{A} \to [0,1],
\]

где \(\mathcal{A}\) — множество осей из `data/character-schema.ts`.

Конвенции:

- **0.5** — нейтральная точка;
- отсутствие оси трактуется как **0.5** во многих формулах (например ToM использует `aVec[axis] ?? 0.5`).

Инварианты:

1) значения должны быть конечными числами;
2) клиппинг в [0,1] обязателен на этапе использования (см. `clamp01` в разных модулях);
3) добавленная ось начинает влиять на поведение только когда её начинают читать веса/конфиги (ToM, Lens, Goal Lab).

Подробно про математику осей и метрики похожести — `02_AXIS_SPACE.md`.

## 4) Traits/body как атомы `feat:char:*`

Линза субъективности читает **черты** и **текущее состояние** из атомов вида:

- `feat:char:<selfId>:trait.paranoia`
- `feat:char:<selfId>:trait.sensitivity`
- `feat:char:<selfId>:trait.experience`
- `feat:char:<selfId>:trait.ambiguityTolerance`
- `feat:char:<selfId>:trait.hpaReactivity`
- `feat:char:<selfId>:trait.normSensitivity`
- `feat:char:<selfId>:body.stress`
- `feat:char:<selfId>:body.fatigue`

Источник истины: `lib/context/lens/characterLens.ts` (`getMag(...)` + fallbacks).

Контракт: если модуль начинает читать новую `feat:char:*` фичу, она обязана быть сгенерирована **раньше** этой стадии (см. `07_PIPELINE_SPEC.md`).

## 5) Минимальный профиль персонажа, чтобы система была “не усреднённой”

Чтобы агент получался отличимым, должны существовать (как минимум):

1) `vector_base` с неплоскими значениями;
2) набор ключевых `feat:char:*:trait.*` (иначе линза возьмёт дефолты и сгладит поведение);
3) (опционально, но желательно) личные приоритеты `ctx:prio:*` (Goal Lab усиливает важные контекстные оси именно для этого агента).

## 6) Где описывать параметры (важно для документации)

- **Ось характера** (психология) → `data/character-schema.ts` (A–G) + значения в `vector_base`.
- **Телесный/ресурсный параметр с единицами** → в schema как блок с `path` (например `body.reserves.sleep_debt_h`) и далее как атомы `world:*`/`feat:char:*`.
- **Линза/ToM/Goals** → всегда документировать вместе с формулой и ссылкой на место в коде.

Связанные документы:
- `03_CHARACTER_LENS.md` (оператор субъективности)
- `04_TOM_DYAD_MODEL.md` (A о B)
- `05_GOAL_LAB_MATH.md` (цели/режимы/гистерезис)
- `07_PIPELINE_SPEC.md` (стадии и обязательные namespaces)
