# 6) Объяснимость: энергия на графе атомов (`propagateAtomEnergy`)

**Источник истины:** `lib/graph/atomEnergy.ts`.

Энергия — это **оверлей объяснимости**: она не является “физикой мира”, а показывает, *какие атомы и через какие зависимости поддерживают выбранные цели/сигналы*.

## 6.1. Граф атомов

Граф строится по `trace.usedAtomIds`:
- ребро `u → v` означает: атом `v` использовал `u` как зависимость.

Это реализовано в `lib/graph/atomGraph.ts` (строитель) и используется Goal Lab UI.

## 6.2. Источники энергии

Источники берутся из `SignalField` (`lib/goals/signalField.ts`).

Для каждого канала `ch` есть набор `sources` — атомов, которые являются первичными носителями сигнала.

Сеeding для источника `a`:
\[
E^{(0)}(a)=\mathrm{atomWeight}(a)=\mathrm{clamp01}(magnitude(a))\cdot\mathrm{clamp01}(confidence(a)).
\]

Можно задать `atomWeightFn(ch,a)` для канало-специфической калибровки (например, учитывать индивидуальные кривые агент-канала).

## 6.3. Динамика распространения

Параметры:
- `steps` (по умолчанию 6, ограничение 0..64)
- `decay` \(\delta\in[0,1]\) (по умолчанию 0.25)

На каждом шаге энергия узла \(u\) делится на:
- retention: \(\delta E_u\)
- injected: \((1-\delta)E_u\)

Если у узла нет исходящих рёбер (sink), injected остаётся на узле.

Если исходящие есть и их \(deg^+(u)=k\), то доля на каждое ребро:
\[
flow_{u\to v}=\frac{(1-\delta)E_u}{k}.
\]

## 6.4. Attribution (кто “виноват” в энергии узла)

Для каждого узла ведётся top-K карта вкладов первичных источников:

- при retention переносится вклад текущего узла масштабом \(\delta\);
- при spread переносится вклад текущего узла масштабом \((1-\delta)/k\).

Для памяти используется `Map<atomId, amount>` и **prune до topK** на каждом merge (`mergeScaledTopK`).

Выход:
- `attributionByChannel[ch][nodeId] = [{atomId, amount}, ...]` (top-K).

## 6.5. Что эта энергия НЕ означает

1) Это не “реальная энергия” персонажа.

2) Это не гарантия причинности.

3) Это инструмент объяснимости: “через какие зависимости сигнал распространяется по графу”.

## 6.6. Контракт корректности

1) Граф должен быть ацикличным или почти ацикличным (self-cycles запрещены).

2) `trace.usedAtomIds` должен ссылаться только на реально существующие атомы.

3) Источники `SignalField` должны быть нормализованы (`normalizeAtom`), иначе веса будут NaN и seed пропадёт.
