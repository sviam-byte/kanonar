// lib/context/catalog/generateMissingSpecs.ts
// Dev helper: generate AtomSpec stubs for ids that currently don't match any spec.
// Intended workflow:
// 1) Open GoalLab -> Pipeline Debug Area -> Coverage -> missingSpec
// 2) Copy the list into console or use exported list, then call generateAtomSpecStubs(list)
// 3) Paste result into lib/context/catalog/atomSpecs.ts (and refine meaning/formula/tags)

import type { AtomSpec } from './types';

function esc(s: string) {
  return s.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
}

function guessNsKind(id: string) {
  const parts = id.split(':');
  const ns = parts[0] || 'atom';
  const kind = parts[1] || 'metric';
  return { ns, kind, parts };
}

function asRegexLiteralExact(id: string) {
  // Escape regex metacharacters except ":" and "-" "_" "." which are safe literal.
  const re = id.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return `new RegExp('^${re}$')`;
}

function defaultTitle(ns: string, kind: string) {
  return `${ns}:${kind}`;
}

function defaultMeaning(id: string) {
  return `TODO: описать смысл атома "${id}". Сейчас это автосгенерированный stub.`;
}

function defaultTags(ns: string) {
  // very light heuristic
  if (ns === 'world') return `['world']`;
  if (ns === 'ctx') return `['ctx']`;
  if (ns === 'tom') return `['tom']`;
  if (ns === 'rel') return `['rel']`;
  if (ns === 'emo') return `['emo']`;
  if (ns === 'app') return `['app']`;
  if (ns === 'obs') return `['obs']`;
  if (ns === 'feat') return `['feat']`;
  if (ns === 'cap') return `['cap']`;
  if (ns === 'trace') return `['trace']`;
  if (ns === 'mind') return `['mind']`;
  return `['misc']`;
}

export function generateAtomSpecStubs(ids: string[], opts?: { prefix?: string }) {
  const unique = Array.from(new Set(ids.map(x => String(x).trim()).filter(Boolean)));
  unique.sort((a, b) => a.localeCompare(b));

  const prefix = opts?.prefix || 'auto';

  const blocks = unique.map((id) => {
    const { ns, kind } = guessNsKind(id);
    const specId = `${prefix}.${ns}.${kind}`;
    const title = defaultTitle(ns, kind);
    const meaning = defaultMeaning(id);
    const tags = defaultTags(ns);
    const re = asRegexLiteralExact(id);

    return `  {\n` +
      `    specId: '${esc(specId)}',\n` +
      `    idPattern: ${re},\n` +
      `    title: _p => \`${esc(title)}\`,\n` +
      `    meaning: _p => \`${esc(meaning)}\`,\n` +
      `    scale: { min: 0, max: 1, lowMeans: 'низко', highMeans: 'высоко' },\n` +
      `    tags: ${tags}\n` +
      `  }`;
  });

  return `// --- AUTOGENERATED STUB SPECS (paste + refine) ---\n` +
    blocks.join(',\n') +
    `\n// --- END AUTOGENERATED ---\n`;
}

// Optional: helper to group ids by namespace for readability.
export function groupIdsByNs(ids: string[]) {
  const out: Record<string, string[]> = {};
  for (const raw of ids) {
    const id = String(raw).trim();
    if (!id) continue;
    const ns = id.split(':')[0] || 'atom';
    out[ns] = out[ns] || [];
    out[ns].push(id);
  }
  for (const k of Object.keys(out)) out[k].sort((a, b) => a.localeCompare(b));
  return out;
}

// If you want this callable from browser console easily, you can attach it in dev tools
// by importing it in a debug-only file and assigning to (window as any).generateAtomSpecStubs = ...
